---
layout: post
comments: true
title: Semantic Segmentation for Imitation Learning - Halite IV Competition
excerpt: "I will show how a data-driven approach can mimic behaviours of other bots that are extremely hard to code."
mathjax: true
---

**Introduction**

In September 2020, I and my team, named "KhaVo Dan Gilles Robga Tung", finished very high (rank 9/1140) in a world-class AI programming challenge "Halite by Two Sigma" held on Kaggle.
In this post I would like to represent my team to publish our solution, and my personal discussions about this competition.

In detail, you will understand:
+ What is this competition about
+ How challenging it is to hard-code a bot that can compete well
+ How a data-driven approach can massively mitigate this challenge and produce unexpectedly outstanding result


**The Competition Game Rules**
The full game rules are described here [insert link]. I only extract some key traits as follows.

- There are 4 players (battle royale style) competing in each "episode", or game.
- Each player starts with 5000 halite and 1 ship.
- At each time step, a ship can choose from 6 actions: NORTH, EAST, SOUTH, WEST, CONVERT, and None (stay idle).
- Each ship can CONVERT itself into a shipyard (or base). Conversion fee is 500 halite. For the other moving actions or staying idle, there is no fee.
- If the ship stays idle, it can mine 25% of halite from the position it is on, and adds to its "cargo". Its cargo is unlimited.
- Each base cannot move, and can choose from 2 actions: SPAWN and None (do nothing). SPAWN means that the base will spawn a new ship on its position. SPAWN fee is 500 halite.
- Ships need to be move back to any base to deposit its cargo. The deposited halite will be added to the bank. This is similar to a Starcraft game.
- In order to spend halite for SPAWN or CONVERT, halite must be in the bank (except the case that a ship wants to CONVERT itself, so its cargo is valid to be spent)
- At any time step, multiple ships (from all teams, including friendly ships) can step on the same position. In this case, the lightest ship (the ship with least cargo) will destroy all other ships. In case of tie, all ships are destroyed.
- A ship stepping on an enemy base will destroy that base.
- If multiple ships stepping on a base, then ship collision is done first, then ship-base collision later. The full turn resolution order is described in the full game rules.
- Halite on the map is randomly and symmetrically distributed at the start of the game.
- Halite in each cell regenerates by 2% per turn, up to a maximum of 500 halite.
- The game lasts a maximum of 400 turns.
- At the end of the game, player ranking (1,2,3,4) is calculated based on final banked halite.

Phew, sorry for making you reading that boring rules. Just watch this game and you'll see how a game flows!

<div class="imgcap">
<img src="/images/halite_full.gif" width="600">
<div class="thecap">A typical full game of 4 high-scoring bots.</div>
</div>

As we can see, despite the simple game rules, the match is extremely competitive. Hundred of ships were fierce fighting for each halite cell. The logic to make a bot work well is certainly not simple, as it takes into account multiple aspects of the game. For simplicity, I will describe some traits that contribute to a good bot:
- How to move all ship into various cells to optimize the halite per turn.
- How to consider which area should we go to, i.e., avoid areas with densely populated enemies.
- When and how to deposit a ship, i.e., too heavy ships are prone to be destroyed, but returning to frequent might decrease halite mined.
- How to detect an isolated enemy ship, and how to move our herd of light ships to kill it.
- When to spawn new ships. Spawning is a crucial factor, as spawning too many/too few greatly affect the game mechanics: mining-focus and halite save (few ships) or attack-focus and dominate (many ships).
- When and where to convert a ship into a base.
- How to track and rank opponents in order to make attack targets or avoid collisions.
- ...

Each of the mentioned points above caused us a great headache. It is more like a parameter tuning task, but this "parameter" is not simple a set of numbers than can vary, but it is a whole mess of programming code.

Anyway, we managed to have some very decent variants of manual bots that work considerably well in the live leaderboard (LB). Wait! What is a LB? Let me quickly explain as well

**How the live leaderboard ranking works**
The most interesting feature of this competition is the live LB ranking. Everybody can submit their own bots everyday. Each bot will start with 600 points representing its "skill" level. Continually, bots from all teams will be drawn against each other (with similar skill) to form a 4-player battle royale match (all 4 bots must be from 4 different teams). When a match finishes, 4 bots will be ranked (1,2,3,4) based on their final halite. The 1st place and 2nd place teams will be rewarded some points, and the 3rd and 4th place teams will be penalized some points. As you can imagine a very good bot will win most of the matches and continue to increase its "skill" points, until it fights with bots with similar high skill and lose. The matches for the whole pool of thousands of bots are played restlessly until the deadline day, which is 3 months apart from the competition commence day. In other words, this matching system is similar to an ELO rating in chess, if one is familiar with chess ratings. A one-week-old bot may play several hundreds of matches, guaranteeing its skill score convergence on the LB.

**How a manual approach cause such a headache**
Now let us go back to discussing the manual bot. To resolve various questions mentioned, one needs a bot "framework" to begin programming with. One typical framework is shown below

<div class="imgcap">
<img src="/images/manualbot.png" width="800">
<div class="thecap">High summary of a manual bot.</div>
</div>

At each time step, we know everything about the game, including the position of all our/enemy ships/bases, how much halite/cargo every one has, and also past time steps information. That means we also know how opponents move in previous steps, and we can aggregate/accumulate some game statistics as well, such as how much halite had each enemy gained per turn, how many kills did they commit... Using all these information, one can perform a two-stage assignment problem to assign move to each ship.
- Stage 1: Assigning a mission to each ship, with some input parameters from the global information, and output parameters indicating the properties of the mission, i.e., which enemy to attack is an output parameter.
- Stage 2: Assigning a move to each ship, based on the assigned mission in stage 1. For instance, a "mining" mission for ship A with target cell (12, 17) can simply guide ship A from its current position, such as (10, 10), to (12, 17) to the cell that is 1-step nearer to (12, 17), that is (11, 10) or (10, 11). 

The headache begins. Seeing this board state with more than 30 ships, how do we assign the optimal mission for each ship? Which ships need to mine, which ships to attack, to harass, to deposit...? 

Even if we managed to assign, say, ships 1,2,3,4 to attack an enemy ship (5), how do we chase the prey effectively?

I may need to "quickly" explain how to make an "attack" mission look good. Remember, this is only 1 among lots of possible missions.

**A manual way to attack and kill an enemy ship**


<div class="imgcap">
<img src="/images/mlbot.png" width="800">
<div class="thecap">High summary of a machine learning bot.</div>
</div>


<div class="imgcap">
<img src="/images/segmentation_halite.png" width="600">
<div class="thecap">How semantic segmentation in computer vision relates to multi-agent learning.</div>
</div>



